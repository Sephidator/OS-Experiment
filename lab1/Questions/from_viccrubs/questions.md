# 问题清单

## 1. boot.asm文件中，org 07c00h的作用

告诉编译器，这段代码将会加载到内存0x7c00的地方，用来正确地定位BootMessage的地址。


## 2. 为什么把boot.bin放在第一个扇区？直接复制为什么不行？

计算机启动后，BIOS在各个可用存储设备的第一个扇区寻找其以0xaa55结尾（其实就是直接看0x01FE和0x01FF这两个地址的数据），当找到一个时，认定此扇区是启动扇区。把第一个扇区的512个字节全部复制到0x7c00，然后跳转过去，移交控制权。

所谓直接复制是基于文件系统的。由于第一扇区的特殊性（可能被认作启动扇区等），所以是在文件系统里是隐藏的，防止偶然情况（比如往那个位置存的文件，正好在0x01FE和0x01FF是0xaa55）或者恶意攻击。

## 3. loader的作用有哪些？

BootLoader

初始化硬件设备、建立内存空间的映射图，从而将系统的软硬件环境带到一个合适的状态，以便为最终调用操作系统内核准备好正确的环境。也就是准备运行操作系统的程序。

Loader 

负责程序的加载。它是程序运行中的一个步骤，加载器会将程序置放在存储器中，让它开始运行。

加载程序的步骤包括，

1. 读取可执行文件，

2. 将可执行文件的内容写入存储器中

3. 开展其他所需的准备工作（比如如果是静态重定位，在这时代码里逻辑地址会被改成物理地址），准备让可执行文件运行。

当加载完成之后，操作系统会将控制权交给 加载的代码，让它开始运作。


```assembly
mov al, [L1]
mov eax, L1
mov [L1], ah
mov eax, [L6]
add eax, [L6]
add [L6], eax
mov al, [L6]
```

## 4. L1，L6各标识了一个字节（8bit）的数据，eax是一个16位的寄存器，说明上面每行代码的意思。

举例：

```assembly
L1: db 1
L6: db 6
```

1. 将L1的值看作内存地址，将这个内存地址的一个字节写入al，即eax的低8位。这里就是说把L1所标识的数据（1）写入al。

2. 将L1的值的地址写入eax。这里就是把L1所标识的1所在的内存地址写入eax。

3. 将L1的值看作内存地址，将ah的值写入这个内存地址。这里就是把ah的值写入内存地址0x1

4. 将L6的值看作内存地址，将这个内存地址以及其接下来的3个地址按小端顺序写入eax

5. 将L6的值看作内存地址，将这个内存地址以及其接下来的3个地址按小端顺序解释成一个32位整数，然后与eax的值相加，将结果放入eax.

6. 将L6的值看作内存地址，将这个内存地址以及其接下来的3个地址按小端顺序解释成一个32位整数，然后与eax的值相加，将结果写回以这个内存地址开始的4个内存地址。

7. 将L6的值看作内存地址，将这个内存地址的值写入al。这里就是把6写入al。

## 5. `times 510-($-$$) db 0`中的数字为什么是510？$和$$分别表⽰什么？不用times指令怎么写（等价命令）？ 

由于程序需要撑满512个字节以让BIOS能够识别到最后2个字节0x55和0xaa，由在这行语句之后dw 0x55aa设置。所以这里需要撑满前510字节的位置。

$代表当前行被汇编后的地址。这里其实就是字符串结束后的那个地址0x7C26。

$$代表一个section的开始初被汇编后的地址。这里就是程序编译后的开始地址，也就是org所指定的0x7C00。

等价命令：

使用预处理指令（其实times就是一个很简单的预处理指令）

https://www.nasm.us/doc/nasmdoc4.html#section-4.5

```
%rep 510-($-$$) 
db 0 
%endrep
```

%rep后跟重复的次数，这里$和$$含义是不变的
%rep后、%endrep前的内容就会重复这么多词。

## 6. 解释 `L10 db "w","o","r","d",0`这条语句的意义，并说明0的作用。

即填充"word\0"这个字符串在某个地址，并用L10指代这个地址。

0的作用是标志字符串的结束。

## 7. `L1 db 0 L2 dw 1000`中的L1、L2是连续存储的吗？即是否L2就存储在L1之后？

是。

看由此代码反汇编出来的`./7/distest.asm`文件，内容为00E803，地址0的值00即为0，地址1和地址2的分别为E8和03，用小端解释为0x3E8，即1000.


## 8. 要是不知道L6标识的是多⼤的数据，下⾯这句话对不对？mov [L6], 1 

不正确。需要指定大小以让系统知道写入多少字节的数据。

比如mov [L6], byte 1，即将1看作一个字节。那么这条语句的作用是把L6看作内存地址，往这个内存地址写入字节1。

## 9. 如何处理输入输出？在代码里哪里体现出来？

在裸机情况下，使用10h号中断与显示设备进行交互（输入）。

在有操作系统的情况下，使用系统调用（最后还是中断）进行交互。

在斐波拉契例子里，处理输入在readInt_read里，通过0号系统调用read(stdin, buffer, length)读入输入字符串。

```
readInt_read:
        mov rax, 0  ; read
        mov rdi, 0  ; stdin
        mov rsi, rsp ; buffer pointer
        mov rdx, 1 ; length
        syscall
        movzx rax, byte [rsp] ; result is in [rsp], move it to rax
```

处理输入在printf里。先使用strLength计算出字符串的长度，再使用1号系统调用write(stdout, pointer, size)输出。

```
printf:
        push rbp
        mov rbp, rsp
        call strLength
        mov rdx, rax ; size
        mov rsi, rdi ; pointer
        mov rdi, 1 ; stdout
        mov rax, 1 ; write
        syscall
        leave
        ret
```

## 10. 什么来保存前一次运算结果？在代码中哪里体现出来？

使用寄存器或者内存地址以及标志寄存器保存前一次运算结果。

在斐波拉契例子里，

如果是说的两次计算中途的那个前一次运算结果，是放在numberTemp的。

```
number1: times PRECISION db 0
number2: times PRECISION db 0
numberTemp: times PRECISION db 0
```

如果是说高精度加法的前一次运算结果，是保存在寄存器里的。详细解释如下：

使用以下方法进行高精度相加。

**两个数对应字节相加，其结果除以100，余数存放于目标地址对应字节，结果设置为进位，参与下一位的相加。**

1234567 + 2345678

存储为 67 45 23 1 和 78 56 34 2
首先加 67 + 78 = 145，除以100，进位1，结果第一字节为45，
进到下一字节，循环。 

在hpAdd方法里，使用r15存放上一次的进位，用于下一字节的相加。

push r15 ; r15 carries CF

r8为恒值100，最后将会把加法结果除以100，其结果（rax里）交给r15，用于下一字节相加。而余数（rdx，由于余数必小于100，存放于最低字节中，则直接使用dl）则为本字节相加结果，存放于目标地址本字节中。

mov r15, rax  ; carry to r15
mov [rdi], dl ; remainder to [rdi]

## 11. 有哪些段寄存器？

32位下有6个。

CS——代码段寄存器(Code Segment Register)，其值为代码段的段值； 
DS——数据段寄存器(Data Segment Register)，其值为数据段的段值； 
ES——附加段寄存器(Extra Segment Register)，其值为附加数据段的段值； 
SS——堆栈段寄存器(Stack Segment Register)，其值为堆栈段的段值； 
FS——附加段寄存器(Extra Segment Register)，其值为附加数据段的段值； 
GS——附加段寄存器(Extra Segment Register)，其值为附加数据段的段值。


## 12. 8086/8088存储单元的物理地址⻓，CPU总线的数量，可以直接寻址的物理地址空间。 

一个存储单元为1 byte，8bit，物理地址长20位

Intel 8086 微处理器有16位寄存器和16位外部数据总线，20位地址总线，寻址为1MB的地址空间。Intel 8088 微处理器的外部数据总线为8位，其他与8086是一样的。   

1 MB（因为20位地址总线）

## 13. 如何根据逻辑地址计算物理地址？ 

实模式与虚拟86模式下，一个段总是长64,536字节（16位段内偏移地址）。在段寄存器内的16位段选择符（segment selector）被解释为20位线性地址空间的高16位，称为段地址；其余的低4位全为0。段地址与16位段内偏移地址相加产生线性地址，同时也是这种内存模式下的物理地址。

Intel 80286处理器仍然使用16位段寄存器与16位的段内偏移地址，但保护模式下支持访问224（16M）字节的内存。16位段寄存器内不再是段地址，16位段寄存器的高13位被称作段选择符（segment selector），其值是到段描述符表的索引值。段描述符中包含了24位的段开始的基地址，20位的段长度。段开始地址与段内偏移地址相加即为内存物理地址。段的长度上限为220=1M字节。


## 14. 寄存器的寻址模式

**立即寻址** 

`mov ax, 0x1234 `

立即数的长度要小于等于寄存器的长度，如果不的话，会被截断并报以下警告

> warning: byte data exceeds bounds [-w+number-overflow]`

实验： ./14/overflow

**寄存器寻址**：

`mov ah, al`

也就是把某个寄存器当作地址。长度不一样直接报错

> overflow.asm:2: error: invalid combination of opcode and operands

实验： ./14/overflow/overflow.asm:2

**直接寻址**

`mov rdx, [123h]`

直接把地址放在方括号中。

**寄存器间接寻址**

`mov edx, [edx]`

寄存器间接寻址的地址放在寄存器中，把寄存器放在方括号中。会读取寄存器的值对应内存地址的数据。

**寄存器相对寻址**

`mov edx, [edx+1]`

寄存器间接寻址的地址放在寄存器中，把寄存器放在方括号中，再加上偏移量。会读取(寄存器的值+偏移量)对应内存地址的数据。

**基址+变址寻址**

`mov bx, [bx+si]`

寄存器间接寻址的地址放在寄存器中，把寄存器放在方括号中，再加上寄存器。会读取(前一个寄存器的值+后一个寄存器的值)对应内存地址的数据。

**相对基址+变址寻址**

`mov bx, [bx+si+1]`

寄存器间接寻址的地址放在寄存器中，把寄存器放在方括号中，再加上寄存器，再加上偏移量。会读取(前一个寄存器的值+后一个寄存器的值+偏移量)对应内存地址的数据。


## 15. 几个常用指令的作用（如 MOV， LEA 等）

mov在上面，一句话，mov dest, src

lea传送地址

`LEA r16/32/64,m`

r16/32/64就是某个寄存器，m是一个尝试读取内存的表达式（说白了就是方括号括起来的）

比如：

`lea EDX, [EBX + 8*EAX + 4]`

会把[ebx+8\*eax+4]这个**本来会去读取内存的表达式**的内存地址计算出来(也就是ebx的值+8*eax的值+4)传入edx然后就没了！不去真的读内存

也就是等价于`mov edx, ebx+8*eax+4`但是这是mov不支持的！mov在没有方括号的时候不能有计算（看14）

而且lea也不会修改标志寄存器，而add、mul啥的会。


## 16. 主程序与子程序的几种参数传递方式

1. 利用寄存器传递参数

比如运行在x86_64下的64位Linux就默认，前六个参数（如果有）依次放在rdi, rsi, rdx, rcx, r8, r9。

2. 利用约定的存储单元传递参数

如果参数太多（或者很大或者其他需求），可以规定把参数放在某个事先预定好的存储单元中。

3. 利用栈传递参数

如果参数太多，可以在call函数前先把参数按顺序压栈（一般来说是最后到最前，在x86_64 Linux x64下的就是最后一个参数到第七个）.

> Once registers are assigned, the arguments passed in memory are pushed on the stack in reversed (right-to-left) order.

https://software.intel.com/sites/default/files/article/402129/mpx-linux64-abi.pdf

4. 利用call后面的空间传递参数

就是把参数放在call指令的后面，被调用函数通过返回地址（正好是call指令的后一条地址）就能找到参数。这样代码和数据混合在一起了，很耦合，不推荐。


举例

```

        call func
        db 1
        db 2
        db 3

...

func:   ; rsp now points to the return address of the caller
        ; exactly where parameters are stored.
        mov rax, byte [rsp] ; rax is 1
        mov rax, byte [rsp+1]; rax is 2

```